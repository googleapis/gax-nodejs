<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>google-gax documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/material.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">google-gax documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>ServiceConfig</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/gax.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#methods">methods</a>
                                </li>
                                <li>
                                        <a href="#retry_codes">retry_codes</a>
                                </li>
                                <li>
                                        <a href="#retry_params">retry_params</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="methods"></a>
                                        <span class="name"><b>methods</b><a href="#methods"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>methods:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="retry_codes"></a>
                                        <span class="name"><b>retry_codes</b><a href="#retry_codes"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>retry_codes:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="retry_params"></a>
                                        <span class="name"><b>retry_params</b><a href="#retry_params"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>retry_params:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {BundleOptions} from &#x27;./bundlingCalls/bundleExecutor&#x27;;

/**
 * Encapsulates the overridable settings for a particular API call.
 *
 * &#x60;&#x60;CallOptions&#x60;&#x60; is an optional arg for all GAX API calls.  It is used to
 * configure the settings of a specific API call.
 *
 * When provided, its values override the GAX service defaults for that
 * particular call.
 *
 * Typically the API clients will accept this as the second to the last
 * argument. See the examples below.
 * @typedef {Object} CallOptions
 * @property {number&#x3D;} timeout - The client-side timeout for API calls.
 * @property {RetryOptions&#x3D;} retry - determines whether and how to retry
 *   on transient errors. When set to null, the call will not retry.
 * @property {boolean&#x3D;} autoPaginate - If set to false and the call is
 *   configured for paged iteration, page unrolling is not performed, instead
 *   the callback will be called with the response object.
 * @property {Object&#x3D;} pageToken - If set and the call is configured for
 *   paged iteration, paged iteration is not performed and requested with this
 *   pageToken.
 * @property {number} maxResults - If set and the call is configured for
 *   paged iteration, the call will stop when the number of response elements
 *   reaches to the specified size. By default, it will unroll the page to
 *   the end of the list.
 * @property {boolean&#x3D;} isBundling - If set to false and the call is configured
 *   for bundling, bundling is not performed.
 * @property {BackoffSettings&#x3D;} longrunning - BackoffSettings used for polling.
 * @property {Function&#x3D;} promise - A constructor for a promise that implements the ES6
 * specification of promise which will be used to create promises. If not
 * provided, native promises will be used.
 * @example
 * // suppress bundling for bundled method.
 * api.bundlingMethod(
 *     param, {optParam: aValue, isBundling: false}, function(err, response) {
 *   // handle response.
 * });
 * @example
 * // suppress streaming for page-streaming method.
 * api.pageStreamingMethod(
 *     param, {optParam: aValue, autoPaginate: false}, function(err, page) {
 *   // not returning a stream, but callback is called with the paged response.
 * });
 */

/**
 * Per-call configurable settings for retrying upon transient failure.
 * @typedef {Object} RetryOptions
 * @property {String[]} retryCodes
 * @property {BackoffSettings} backoffSettings
 */
export class RetryOptions {
  retryCodes: number[];
  backoffSettings: BackoffSettings;
  constructor(retryCodes: number[], backoffSettings: BackoffSettings) {
    this.retryCodes &#x3D; retryCodes;
    this.backoffSettings &#x3D; backoffSettings;
  }
}

/**
 * Parameters to the exponential backoff algorithm for retrying.
 * @typedef {Object} BackoffSettings
 * @property {number} initialRetryDelayMillis - the initial delay time,
 *   in milliseconds, between the completion of the first failed request and the
 *   initiation of the first retrying request.
 * @property {number} retryDelayMultiplier - the multiplier by which to
 *   increase the delay time between the completion of failed requests, and the
 *   initiation of the subsequent retrying request.
 * @property {number} maxRetryDelayMillis - the maximum delay time, in
 *   milliseconds, between requests. When this value is reached,
 *   &#x60;&#x60;retryDelayMultiplier&#x60;&#x60; will no longer be used to increase delay time.
 * @property {number} initialRpcTimeoutMillis - the initial timeout parameter
 *   to the request.
 * @propetry {number} rpcTimeoutMultiplier - the multiplier by which to
 *   increase the timeout parameter between failed requests.
 * @property {number} maxRpcTimeoutMillis - the maximum timeout parameter, in
 *   milliseconds, for a request. When this value is reached,
 *   &#x60;&#x60;rpcTimeoutMultiplier&#x60;&#x60; will no longer be used to increase the timeout.
 * @property {number} totalTimeoutMillis - the total time, in milliseconds,
 *   starting from when the initial request is sent, after which an error will
 *   be returned, regardless of the retrying attempts made meanwhile.
 */
export interface BackoffSettings {
  maxRetries?: number;
  initialRetryDelayMillis: number;
  retryDelayMultiplier: number;
  maxRetryDelayMillis: number;
  initialRpcTimeoutMillis?: number | null;
  maxRpcTimeoutMillis?: number | null;
  totalTimeoutMillis?: number | null;
  rpcTimeoutMultiplier?: number | null;
}

/**
 * Parameter to configure bundling behavior.
 * @typedef {Object} BundleOptions
 * @property {number} elementCountThreshold -
 *   the bundled request will be sent once the count of outstanding elements
 *   in the repeated field reaches this value.
 * @property {number} elementCountLimit -
 *   represents a hard limit on the number of elements in the repeated field
 *   of the bundle; if adding a request to a bundle would exceed this value,
 *   the bundle is sent and the new request is added to a fresh bundle. It is
 *   invalid for a single request to exceed this limit.
 * @property {number} requestByteThreshold -
 *   the bundled request will be sent once the count of bytes in the request
 *   reaches this value. Note that this value is pessimistically approximated
 *   by summing the bytesizes of the elements in the repeated field, and
 *   therefore may be an under-approximation.
 * @property {number} requestByteLimit -
 *   represents a hard limit on the size of the bundled request; if adding
 *   a request to a bundle would exceed this value, the bundle is sent and
 *   the new request is added to a fresh bundle. It is invalid for a single
 *   request to exceed this limit. Note that this value is pessimistically
 *   approximated by summing the bytesizes of the elements in the repeated
 *   field, with a buffer applied to correspond to the resulting
 *   under-approximation.
 * @property {number} delayThreshold -
 *   the bundled request will be sent this amount of time after the first
 *   element in the bundle was added to it.
 */

export interface CallOptions {
  timeout?: number;
  retry?: RetryOptions | null;
  autoPaginate?: boolean;
  pageToken?: string;
  pageSize?: number;
  maxResults?: number;
  maxRetries?: number;
  // tslint:disable-next-line no-any
  otherArgs?: {[index: string]: any};
  bundleOptions?: BundleOptions | null;
  isBundling?: boolean;
  longrunning?: BackoffSettings;
  promise?: PromiseConstructor;
}

export class CallSettings {
  timeout: number;
  retry?: RetryOptions | null;
  autoPaginate?: boolean;
  pageToken?: string;
  pageSize?: number;
  maxResults?: number;
  // tslint:disable-next-line no-any
  otherArgs: {[index: string]: any};
  bundleOptions?: BundleOptions | null;
  isBundling: boolean;
  longrunning?: BackoffSettings;
  promise: PromiseConstructor;

  /**
   * @param {Object} settings - An object containing parameters of this settings.
   * @param {number} settings.timeout - The client-side timeout for API calls.
   *   This parameter is ignored for retrying calls.
   * @param {RetryOptions} settings.retry - The configuration for retrying upon
   *   transient error. If set to null, this call will not retry.
   * @param {boolean} settings.autoPaginate - If there is no &#x60;pageDescriptor&#x60;,
   *   this attrbute has no meaning. Otherwise, determines whether a page
   * streamed response should make the page structure transparent to the user by
   *   flattening the repeated field in the returned generator.
   * @param {number} settings.pageToken - If there is no &#x60;pageDescriptor&#x60;,
   *   this attribute has no meaning. Otherwise, determines the page token used
   * in the page streaming request.
   * @param {Object} settings.otherArgs - Additional arguments to be passed to
   *   the API calls.
   * @param {Function&#x3D;} settings.promise - A constructor for a promise that
   * implements the ES6 specification of promise. If not provided, native
   * promises will be used.
   *
   * @constructor
   */
  constructor(settings?: CallOptions) {
    settings &#x3D; settings || {};
    this.timeout &#x3D; settings.timeout || 30 * 1000;
    this.retry &#x3D; settings.retry;
    this.autoPaginate &#x3D;
      &#x27;autoPaginate&#x27; in settings ? settings.autoPaginate : true;
    this.pageToken &#x3D; settings.pageToken;
    this.maxResults &#x3D; settings.maxResults;
    this.otherArgs &#x3D; settings.otherArgs || {};
    this.bundleOptions &#x3D; settings.bundleOptions;
    this.isBundling &#x3D; &#x27;isBundling&#x27; in settings ? settings.isBundling! : true;
    this.longrunning &#x3D;
      &#x27;longrunning&#x27; in settings ? settings.longrunning : undefined;
    this.promise &#x3D; &#x27;promise&#x27; in settings ? settings.promise! : Promise;
  }

  /**
   * Returns a new CallSettings merged from this and a CallOptions object.
   *
   * @param {CallOptions} options - an instance whose values override
   *   those in this object. If null, &#x60;&#x60;merge&#x60;&#x60; returns a copy of this
   *   object
   * @return {CallSettings} The merged CallSettings instance.
   */
  merge(options?: CallOptions | null) {
    if (!options) {
      return new CallSettings(this);
    }
    let timeout &#x3D; this.timeout;
    let retry &#x3D; this.retry;
    let autoPaginate &#x3D; this.autoPaginate;
    let pageToken &#x3D; this.pageToken;
    let pageSize &#x3D; this.pageSize;
    let maxResults &#x3D; this.maxResults;
    let otherArgs &#x3D; this.otherArgs;
    let isBundling &#x3D; this.isBundling;
    let longrunning &#x3D; this.longrunning;
    let promise &#x3D; this.promise;
    if (&#x27;timeout&#x27; in options) {
      timeout &#x3D; options.timeout!;
    }
    if (&#x27;retry&#x27; in options) {
      retry &#x3D; options.retry;
    }

    if (&#x27;autoPaginate&#x27; in options &amp;&amp; !options.autoPaginate) {
      autoPaginate &#x3D; false;
    }

    if (&#x27;pageToken&#x27; in options) {
      autoPaginate &#x3D; false;
      pageToken &#x3D; options.pageToken;
    }

    if (&#x27;pageSize&#x27; in options) {
      pageSize &#x3D; options.pageSize;
    }

    if (&#x27;maxResults&#x27; in options) {
      maxResults &#x3D; options.maxResults;
    }

    if (&#x27;otherArgs&#x27; in options) {
      otherArgs &#x3D; {};
      // tslint:disable-next-line forin
      for (const key in this.otherArgs) {
        otherArgs[key] &#x3D; this.otherArgs[key];
      }
      // tslint:disable-next-line forin
      for (const optionsKey in options.otherArgs!) {
        otherArgs[optionsKey] &#x3D; options.otherArgs![optionsKey];
      }
    }

    if (&#x27;isBundling&#x27; in options) {
      isBundling &#x3D; options.isBundling!;
    }

    if (&#x27;maxRetries&#x27; in options) {
      retry!.backoffSettings!.maxRetries &#x3D; options.maxRetries;
      delete retry!.backoffSettings!.totalTimeoutMillis;
    }

    if (&#x27;longrunning&#x27; in options) {
      longrunning &#x3D; options.longrunning;
    }

    if (&#x27;promise&#x27; in options) {
      promise &#x3D; options.promise!;
    }

    return new CallSettings({
      timeout,
      retry,
      bundleOptions: this.bundleOptions,
      longrunning,
      autoPaginate,
      pageToken,
      pageSize,
      maxResults,
      otherArgs,
      isBundling,
      promise,
    });
  }
}

/**
 * Per-call configurable settings for retrying upon transient failure.
 *
 * @param {number[]} retryCodes - a list of Google API canonical error codes
 *   upon which a retry should be attempted.
 * @param {BackoffSettings} backoffSettings - configures the retry
 *   exponential backoff algorithm.
 * @return {RetryOptions} A new RetryOptions object.
 *
 */
export function createRetryOptions(
  retryCodes: number[],
  backoffSettings: BackoffSettings
): RetryOptions {
  return {
    retryCodes,
    backoffSettings,
  };
}

/**
 * Parameters to the exponential backoff algorithm for retrying.
 *
 * @param {number} initialRetryDelayMillis - the initial delay time,
 *   in milliseconds, between the completion of the first failed request and the
 *   initiation of the first retrying request.
 * @param {number} retryDelayMultiplier - the multiplier by which to
 *   increase the delay time between the completion of failed requests, and the
 *   initiation of the subsequent retrying request.
 * @param {number} maxRetryDelayMillis - the maximum delay time, in
 *   milliseconds, between requests. When this value is reached,
 *   &#x60;&#x60;retryDelayMultiplier&#x60;&#x60; will no longer be used to increase delay time.
 * @param {number} initialRpcTimeoutMillis - the initial timeout parameter
 *   to the request.
 * @param {number} rpcTimeoutMultiplier - the multiplier by which to
 *   increase the timeout parameter between failed requests.
 * @param {number} maxRpcTimeoutMillis - the maximum timeout parameter, in
 *   milliseconds, for a request. When this value is reached,
 *   &#x60;&#x60;rpcTimeoutMultiplier&#x60;&#x60; will no longer be used to increase the timeout.
 * @param {number} totalTimeoutMillis - the total time, in milliseconds,
 *   starting from when the initial request is sent, after which an error will
 *   be returned, regardless of the retrying attempts made meanwhile.
 * @return {BackoffSettings} a new settings.
 *
 */
export function createBackoffSettings(
  initialRetryDelayMillis: number,
  retryDelayMultiplier: number,
  maxRetryDelayMillis: number,
  initialRpcTimeoutMillis: number | null,
  rpcTimeoutMultiplier: number | null,
  maxRpcTimeoutMillis: number | null,
  totalTimeoutMillis: number | null
): BackoffSettings {
  return {
    initialRetryDelayMillis,
    retryDelayMultiplier,
    maxRetryDelayMillis,
    initialRpcTimeoutMillis,
    rpcTimeoutMultiplier,
    maxRpcTimeoutMillis,
    totalTimeoutMillis,
  };
}

export function createDefaultBackoffSettings() {
  return createBackoffSettings(100, 1.3, 60000, null, null, null, null);
}

/**
 * Parameters to the exponential backoff algorithm for retrying.
 * This function is unsupported, and intended for internal use only.
 *
 * @param {number} initialRetryDelayMillis - the initial delay time,
 *   in milliseconds, between the completion of the first failed request and the
 *   initiation of the first retrying request.
 * @param {number} retryDelayMultiplier - the multiplier by which to
 *   increase the delay time between the completion of failed requests, and the
 *   initiation of the subsequent retrying request.
 * @param {number} maxRetryDelayMillis - the maximum delay time, in
 *   milliseconds, between requests. When this value is reached,
 *   &#x60;&#x60;retryDelayMultiplier&#x60;&#x60; will no longer be used to increase delay time.
 * @param {number} initialRpcTimeoutMillis - the initial timeout parameter
 *   to the request.
 * @param {number} rpcTimeoutMultiplier - the multiplier by which to
 *   increase the timeout parameter between failed requests.
 * @param {number} maxRpcTimeoutMillis - the maximum timeout parameter, in
 *   milliseconds, for a request. When this value is reached,
 *   &#x60;&#x60;rpcTimeoutMultiplier&#x60;&#x60; will no longer be used to increase the timeout.
 * @param {number} maxRetries - the maximum number of retrying attempts that
 *   will be made. If reached, an error will be returned.
 * @return {BackoffSettings} a new settings.
 *
 */
export function createMaxRetriesBackoffSettings(
  initialRetryDelayMillis: number,
  retryDelayMultiplier: number,
  maxRetryDelayMillis: number,
  initialRpcTimeoutMillis: number,
  rpcTimeoutMultiplier: number,
  maxRpcTimeoutMillis: number,
  maxRetries: number
): BackoffSettings {
  return {
    initialRetryDelayMillis,
    retryDelayMultiplier,
    maxRetryDelayMillis,
    initialRpcTimeoutMillis,
    rpcTimeoutMultiplier,
    maxRpcTimeoutMillis,
    maxRetries,
  };
}

/**
 * Creates a new {@link BundleOptions}.
 *
 * @private
 * @param {Object} options - An object to hold optional parameters. See
 *   properties for the content of options.
 * @return {BundleOptions} - A new options.
 */
export function createBundleOptions(options: BundlingConfig): BundleOptions {
  const params &#x3D; [
    &#x27;element_count_threshold&#x27;,
    &#x27;element_count_limit&#x27;,
    &#x27;request_byte_threshold&#x27;,
    &#x27;request_byte_limit&#x27;,
    &#x27;delay_threshold_millis&#x27;,
  ];
  params.forEach(param &#x3D;&gt; {
    if (param in options &amp;&amp; typeof options[param] !&#x3D;&#x3D; &#x27;number&#x27;) {
      throw new Error(&#x60;${param} should be a number&#x60;);
    }
  });

  const elementCountThreshold &#x3D; options.element_count_threshold || 0;
  const elementCountLimit &#x3D; options.element_count_limit || 0;
  const requestByteThreshold &#x3D; options.request_byte_threshold || 0;
  const requestByteLimit &#x3D; options.request_byte_limit || 0;
  const delayThreshold &#x3D; options.delay_threshold_millis || 0;

  if (
    elementCountThreshold &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
    requestByteThreshold &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
    delayThreshold &#x3D;&#x3D;&#x3D; 0
  ) {
    throw new Error(&#x27;one threshold should be &gt; 0&#x27;);
  }
  return {
    elementCountThreshold,
    elementCountLimit,
    requestByteThreshold,
    requestByteLimit,
    delayThreshold,
  };
}

/**
 * Helper for {@link constructSettings}
 *
 * @private
 *
 * @param {Object} methodConfig - A dictionary representing a single
 *   &#x60;methods&#x60; entry of the standard API client config file. (See
 *   {@link constructSettings} for information on this yaml.)
 * @param {?Object} retryCodes - A dictionary parsed from the
 *   &#x60;retry_codes_def&#x60; entry of the standard API client config
 *   file. (See {@link constructSettings} for information on this yaml.)
 * @param {Object} retryParams - A dictionary parsed from the
 *   &#x60;retry_params&#x60; entry of the standard API client config
 *   file. (See {@link constructSettings} for information on this yaml.)
 * @param {Object} retryNames - A dictionary mapping the string names
 *   used in the standard API client config file to API response
 *   status codes.
 * @return {?RetryOptions} The new retry options.
 */
function constructRetry(
  methodConfig: MethodConfig,
  retryCodes: {[index: string]: string[]},
  retryParams: {[index: string]: {}},
  retryNames: {[index: string]: {}}
): RetryOptions | null | undefined {
  if (!methodConfig) {
    return null;
  }

  let codes: number[] | null &#x3D; null;
  if (retryCodes &amp;&amp; &#x27;retry_codes_name&#x27; in methodConfig) {
    const retryCodesName &#x3D; methodConfig[&#x27;retry_codes_name&#x27;];
    codes &#x3D; (retryCodes[retryCodesName] || []).map(name &#x3D;&gt; {
      return Number(retryNames[name]);
    });
  }

  let backoffSettings: BackoffSettings | null &#x3D; null;
  if (retryParams &amp;&amp; &#x27;retry_params_name&#x27; in methodConfig) {
    const params &#x3D; retryParams[
      methodConfig.retry_params_name
    ] as RetryParamsConfig;
    backoffSettings &#x3D; createBackoffSettings(
      params.initial_retry_delay_millis,
      params.retry_delay_multiplier,
      params.max_retry_delay_millis,
      params.initial_rpc_timeout_millis,
      params.rpc_timeout_multiplier,
      params.max_rpc_timeout_millis,
      params.total_timeout_millis
    );
  }
  return createRetryOptions(codes!, backoffSettings!);
}

/**
 * Helper for {@link constructSettings}
 *
 * Takes two retry options, and merges them into a single RetryOption instance.
 *
 * @private
 *
 * @param {RetryOptions} retry - The base RetryOptions.
 * @param {RetryOptions} overrides - The RetryOptions used for overriding
 *   &#x60;retry&#x60;. Use the values if it is not null. If entire &#x60;overrides&#x60; is null,
 *   ignore the base retry and return null.
 * @return {?RetryOptions} The merged RetryOptions.
 */
function mergeRetryOptions(
  retry: RetryOptions,
  overrides: RetryOptions
): RetryOptions | null {
  if (!overrides) {
    return null;
  }

  if (!overrides.retryCodes &amp;&amp; !overrides.backoffSettings) {
    return retry;
  }

  let codes &#x3D; retry.retryCodes;
  if (overrides.retryCodes) {
    codes &#x3D; overrides.retryCodes;
  }
  let backoffSettings &#x3D; retry.backoffSettings;
  if (overrides.backoffSettings) {
    backoffSettings &#x3D; overrides.backoffSettings;
  }
  return createRetryOptions(codes, backoffSettings);
}

export interface ServiceConfig {
  retry_codes: {[index: string]: string[]};
  retry_params: {[index: string]: RetryParamsConfig};
  methods: {[index: string]: MethodConfig};
}

export interface RetryParamsConfig {
  initial_retry_delay_millis: number;
  retry_delay_multiplier: number;
  max_retry_delay_millis: number;
  initial_rpc_timeout_millis: number;
  rpc_timeout_multiplier: number;
  max_rpc_timeout_millis: number;
  total_timeout_millis: number;
}

export interface MethodConfig {
  retry_codes_name: string;
  retry_params_name: string;
  bundling?: BundlingConfig;
  timeout_millis?: number;
}

export interface BundlingConfig {
  [index: string]: number;
  element_count_threshold: number;
  element_count_limit: number;
  request_byte_threshold: number;
  request_byte_limit: number;
  delay_threshold_millis: number;
}

export interface ClientConfig {
  interfaces?: {[index: string]: ServiceConfig};
}

/**
 * Constructs a dictionary mapping method names to {@link CallSettings}.
 *
 * The &#x60;clientConfig&#x60; parameter is parsed from a client configuration JSON
 * file of the form:
 *
 *     {
 *       &quot;interfaces&quot;: {
 *         &quot;google.fake.v1.ServiceName&quot;: {
 *           &quot;retry_codes&quot;: {
 *             &quot;idempotent&quot;: [&quot;UNAVAILABLE&quot;, &quot;DEADLINE_EXCEEDED&quot;],
 *             &quot;non_idempotent&quot;: []
 *           },
 *           &quot;retry_params&quot;: {
 *             &quot;default&quot;: {
 *               &quot;initial_retry_delay_millis&quot;: 100,
 *               &quot;retry_delay_multiplier&quot;: 1.2,
 *               &quot;max_retry_delay_millis&quot;: 1000,
 *               &quot;initial_rpc_timeout_millis&quot;: 2000,
 *               &quot;rpc_timeout_multiplier&quot;: 1.5,
 *               &quot;max_rpc_timeout_millis&quot;: 30000,
 *               &quot;total_timeout_millis&quot;: 45000
 *             }
 *           },
 *           &quot;methods&quot;: {
 *             &quot;CreateFoo&quot;: {
 *               &quot;retry_codes_name&quot;: &quot;idempotent&quot;,
 *               &quot;retry_params_name&quot;: &quot;default&quot;
 *             },
 *             &quot;Publish&quot;: {
 *               &quot;retry_codes_name&quot;: &quot;non_idempotent&quot;,
 *               &quot;retry_params_name&quot;: &quot;default&quot;,
 *               &quot;bundling&quot;: {
 *                 &quot;element_count_threshold&quot;: 40,
 *                 &quot;element_count_limit&quot;: 200,
 *                 &quot;request_byte_threshold&quot;: 90000,
 *                 &quot;request_byte_limit&quot;: 100000,
 *                 &quot;delay_threshold_millis&quot;: 100
 *               }
 *             }
 *           }
 *         }
 *       }
 *     }
 *
 * @param {String} serviceName - The fully-qualified name of this
 *   service, used as a key into the client config file (in the
 *   example above, this value should be &#x27;google.fake.v1.ServiceName&#x27;).
 * @param {Object} clientConfig - A dictionary parsed from the
 *   standard API client config file.
 * @param {Object} configOverrides - A dictionary in the same structure of
 *   client_config to override the settings.
 * @param {Object.&lt;string, string[]&gt;} retryNames - A dictionary mapping the strings
 *   referring to response status codes to objects representing
 *   those codes.
 * @param {Object} otherArgs - the non-request arguments to be passed to the API
 *   calls.
 * @param {Function&#x3D;} promise - A constructor for a promise that implements the
 * ES6 specification of promise. If not provided, native promises will be used.
 * @return {Object} A mapping from method name to CallSettings, or null if the
 *   service is not found in the config.
 */
export function constructSettings(
  serviceName: string,
  clientConfig: ClientConfig,
  configOverrides: ClientConfig,
  retryNames: {},
  otherArgs?: {},
  promise?: PromiseConstructor
) {
  otherArgs &#x3D; otherArgs || {};
  // tslint:disable-next-line no-any
  const defaults: any &#x3D; {};

  const serviceConfig &#x3D; (clientConfig.interfaces || {})[serviceName];
  if (!serviceConfig) {
    return null;
  }

  const overrides &#x3D; (configOverrides.interfaces || {})[serviceName] || {};
  const methods &#x3D; serviceConfig.methods;
  const overridingMethods &#x3D; overrides.methods || {};
  // tslint:disable-next-line forin
  for (const methodName in methods) {
    const methodConfig &#x3D; methods[methodName];
    const jsName &#x3D; methodName[0].toLowerCase() + methodName.slice(1);

    let retry &#x3D; constructRetry(
      methodConfig,
      serviceConfig.retry_codes,
      serviceConfig.retry_params,
      retryNames
    );
    let bundlingConfig &#x3D; methodConfig.bundling;
    let timeout &#x3D; methodConfig.timeout_millis;
    if (methodName in overridingMethods) {
      const overridingMethod &#x3D; overridingMethods[methodName];
      if (overridingMethod) {
        if (&#x27;bundling&#x27; in overridingMethod) {
          bundlingConfig &#x3D; overridingMethod.bundling;
        }
        if (&#x27;timeout_millis&#x27; in overridingMethod) {
          timeout &#x3D; overridingMethod.timeout_millis;
        }
      }
      retry &#x3D; mergeRetryOptions(
        retry!,
        constructRetry(
          overridingMethod,
          overrides.retry_codes,
          overrides.retry_params,
          retryNames
        )!
      );
    }

    defaults[jsName] &#x3D; new CallSettings({
      timeout,
      retry,
      bundleOptions: bundlingConfig
        ? createBundleOptions(bundlingConfig)
        : null,
      otherArgs,
      promise: promise || Promise,
    });
  }

  return defaults;
}
</code></pre>
    </div>
</div>






                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ServiceConfig.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>

import { promises as fs } from 'fs';
import path from 'path';
export async function getConfig(flags) {
    // check to see if a config file path was passed
    const configPath = flags.config || 'linkinator.config.json';
    let config = {};
    if (flags.config) {
        config = await parseConfigFile(configPath);
    }
    // `meow` is set up to pass boolean flags as `undefined` if not passed.
    // copy the struct, and delete properties that are `undefined` so the merge
    // doesn't blast away config level settings.
    const strippedFlags = Object.assign({}, flags);
    Object.entries(strippedFlags).forEach(([key, value]) => {
        if (typeof value === 'undefined' ||
            (Array.isArray(value) && value.length === 0)) {
            delete strippedFlags[key];
        }
    });
    // combine the flags passed on the CLI with the flags in the config file,
    // with CLI flags getting precedence
    config = Object.assign({}, config, strippedFlags);
    return config;
}
const validConfigExtensions = ['.js', '.mjs', '.cjs', '.json'];
async function parseConfigFile(configPath) {
    const typeOfConfig = getTypeOfConfig(configPath);
    switch (typeOfConfig) {
        case '.json':
            return readJsonConfigFile(configPath);
        case '.js':
        case '.mjs':
        case '.cjs':
            return importConfigFile(configPath);
    }
    throw new Error(`Config file ${configPath} is invalid`);
}
function getTypeOfConfig(configPath) {
    // Returning json in case file doesn't have an extension for backward compatibility
    const configExtension = path.extname(configPath) || '.json';
    if (validConfigExtensions.includes(configExtension)) {
        return configExtension;
    }
    throw new Error(`Config file should be either of extensions ${validConfigExtensions.join(',')}`);
}
async function importConfigFile(configPath) {
    // Use a filthy hack to prevent ncc / webpack from trying to process
    // the runtime dynamic import.  This hurt me more than it disgusts
    // whoever is reading the code.
    const _import = new Function('p', 'return import(p)');
    const config = (await _import(`file://${path.resolve(process.cwd(), configPath)}`)).default;
    return config;
}
async function readJsonConfigFile(configPath) {
    const configFileContents = await fs.readFile(configPath, {
        encoding: 'utf-8',
    });
    return JSON.parse(configFileContents);
}
//# sourceMappingURL=config.js.map